"use strict";const e=(e,t)=>e&&0!==(e.length??0)?e.reduce(t):null,t=(e,t,r=!1)=>{if(!e)return[];return e.slice().sort(!0===r?(e,r)=>t(r)-t(e):(e,r)=>t(e)-t(r))};function*r(e,t,r=1){for(let n=e;n<=t&&(yield n,!(n+r>t));n+=r);}const n=(e,t,n=1)=>Array.from(r(e,t,n)),s=(e,t)=>e?e.reduce(((e,r)=>{const[n,s]=e;return t(r)?[[...n,r],s]:[n,[...s,r]]}),[[],[]]):[[],[]],o=(e,t,r)=>{let n=r;for(let r=1;r<=e;r++)n=t(n,r);return n};class i extends Error{constructor(e){super(),this.errors=e}}const c=e=>new Promise((t=>setTimeout(t,e))),u=e=>async(...t)=>{try{return[null,await e(...t)]}catch(e){return[e,null]}},l=e=>!!e&&e.constructor===Symbol,a=e=>!!e&&e.constructor===Object,p=e=>!!(e&&e.constructor&&e.call&&e.apply),f=e=>{try{return Number(e)===e}catch{return!1}},x=e=>"[object Date]"===Object.prototype.toString.call(e),h=(e,t)=>{if(Object.is(e,t))return!0;if(e instanceof Date&&t instanceof Date)return e.getTime()===t.getTime();if(e instanceof RegExp&&t instanceof RegExp)return e.toString()===t.toString();if("object"!=typeof e||null===e||"object"!=typeof t||null===t)return!1;const r=Reflect.ownKeys(e),n=Reflect.ownKeys(t);if(r.length!==n.length)return!1;for(let n=0;n<r.length;n++){if(!Reflect.has(t,r[n]))return!1;if(!h(e[r[n]],t[r[n]]))return!1}return!0},d=(e,t)=>Object.keys(e).reduce(((r,n)=>({...r,[t(n,e[n])]:e[n]})),{}),m=(e,t)=>e||t?e?t?Object.entries(e).reduce(((e,[r,n])=>({...e,[r]:a(n)?m(n,t[r]):t[r]})),{}):e:t:{},g=(e,t)=>Math.floor(Math.random()*(t-e+1)+e),y=e=>{if(!e||0===e.length)return"";const t=e.toLowerCase();return t.substring(0,1).toUpperCase()+t.substring(1,t.length)},w=e=>{const t=e?.replace(/([A-Z])+/g,y)?.split(/(?=[A-Z])|[\.\-\s_]/).map((e=>e.toLowerCase()))??[];return 0===t.length?"":1===t.length?t[0]:t.reduce(((e,t)=>`${e}${t.charAt(0).toUpperCase()}${t.slice(1)}`))};exports.alphabetical=(e,t,r="asc")=>{if(!e)return[];return e.slice().sort("desc"===r?(e,r)=>`${t(r)}`.localeCompare(t(e)):(e,r)=>`${t(e)}`.localeCompare(t(r)))},exports.boil=e,exports.camal=w,exports.camel=w,exports.capitalize=y,exports.chain=(...e)=>(...t)=>e.slice(1).reduce(((e,t)=>t(e)),e[0](...t)),exports.clone=e=>Object.getOwnPropertyNames(e).reduce(((t,r)=>({...t,[r]:e[r]})),{}),exports.cluster=(e,t=2)=>{const r=Math.ceil(e.length/t);return new Array(r).fill(null).map(((r,n)=>e.slice(n*t,n*t+t)))},exports.compose=(...e)=>e.reverse().reduce(((e,t)=>t(e))),exports.counting=(e,t)=>e.reduce(((e,r)=>{const n=t(r);return{...e,[n]:(e[n]??0)+1}}),{}),exports.dash=e=>{const t=e?.replace(/([A-Z])+/g,y)?.split(/(?=[A-Z])|[\.\-\s_]/).map((e=>e.toLowerCase()))??[];return 0===t.length?"":1===t.length?t[0]:t.reduce(((e,t)=>`${e}-${t.toLowerCase()}`))},exports.debounce=({delay:e},t)=>{let r=null;return(...n)=>{clearTimeout(r),r=setTimeout((()=>t(...n)),e)}},exports.defer=async e=>{const t=[],[r,n]=await u(e)(((e,r)=>t.push({fn:e,rethrow:r?.rethrow??!1})));for(const{fn:e,rethrow:n}of t){const[t]=await u(e)(r);if(n)throw t}if(r)throw r;return n},exports.diff=(e,t,r=(e=>e))=>{if(!e?.length&&!t?.length)return[];if(void 0===e?.length)return[...t];if(!t?.length)return[...e];const n=t.reduce(((e,t)=>({...e,[r(t)]:!0})),{});return e.filter((e=>!n[r(e)]))},exports.draw=e=>{const t=e.length;if(0===t)return null;return e[g(0,t-1)]},exports.first=(e,t)=>e?.length>0?e[0]:t,exports.flat=e=>e.reduce(((e,t)=>[...e,...t]),[]),exports.fork=s,exports.get=(e,t,r=null)=>{if(p(t))try{return t(e)??r}catch{return r}const n=t.split(/[\.\[\]]/g);let s=e;for(const e of n){if(null===s)return r;if(void 0===s)return r;""!==e.trim()&&(s=s[e])}return void 0===s?r:s},exports.group=(e,t)=>e.reduce(((e,r)=>{const n=t(r),s=e[n]??[];return{...e,[n]:[...s,r]}}),{}),exports.intersects=(e,t,r)=>{if(!e||!t)return!1;const n=r??(e=>e),s=t.reduce(((e,t)=>({...e,[n(t)]:!0})),{});return e.some((e=>s[n(e)]))},exports.invert=e=>{if(!e)return{};return Object.keys(e).reduce(((t,r)=>({...t,[e[r]]:r})),{})},exports.isArray=e=>!!e&&e.constructor===Array,exports.isDate=x,exports.isEmpty=e=>{if(!0===e||!1===e)return!0;if(null==e)return!0;if(f(e))return 0===e;if(x(e))return isNaN(e.getTime());if(p(e))return!1;if(l(e))return!1;const t=e.length;if(f(t))return 0===t;const r=e.size;if(f(r))return 0===r;return 0===Object.keys(e).length},exports.isEqual=h,exports.isFloat=e=>f(e)&&e%1!=0,exports.isFunction=p,exports.isInt=e=>f(e)&&e%1==0,exports.isNumber=f,exports.isObject=a,exports.isString=e=>"string"==typeof e||e instanceof String,exports.isSymbol=l,exports.iterate=o,exports.last=(e,t)=>e?.length>0?e[e.length-1]:t,exports.list=n,exports.listify=(e,t)=>{if(!e)return[];const r=Object.entries(e);return 0===r.length?[]:r.reduce(((e,r)=>[...e,t(r[0],r[1])]),[])},exports.lowerize=e=>d(e,(e=>e.toLowerCase())),exports.map=async(e,t)=>{if(!e)return[];let r=[],n=0;for(const s of e){const e=await t(s,n++);r.push(e)}return r},exports.mapEntries=(e,t)=>e?Object.entries(e).reduce(((e,[r,n])=>{const[s,o]=t(r,n);return{...e,[s]:o}}),{}):{},exports.mapKeys=d,exports.mapValues=(e,t)=>Object.keys(e).reduce(((r,n)=>({...r,[n]:t(e[n],n)})),{}),exports.max=(t,r)=>{const n=r||(e=>e);return e(t,((e,t)=>n(e)>n(t)?e:t))},exports.memo=(e,{key:t=null,ttl:r=300}={})=>((e,t,r,n)=>function(...s){const o=r?r(...s):JSON.stringify({args:s}),i=e[o];if(void 0!==i&&i.exp>(new Date).getTime())return i.value;const c=t(...s);return e[o]={exp:(new Date).getTime()+n,value:c},c})({},e,t,r),exports.merge=(e,t,r)=>t||e?t?e?r?e.reduce(((e,n)=>{const s=t.find((e=>r(n)===r(e)));return s?[...e,s]:[...e,n]}),[]):e:[]:e:[],exports.min=(t,r)=>{const n=r||(e=>e);return e(t,((e,t)=>n(e)<n(t)?e:t))},exports.objectify=(e,t,r=(e=>e))=>e.reduce(((e,n)=>({...e,[t(n)]:r(n)})),{}),exports.omit=(e,t)=>e?t&&0!==t.length?t.reduce(((e,t)=>(delete e[t],e)),{...e}):e:{},exports.parallel=async(e,r,o)=>{const c=r.map(((e,t)=>({index:t,item:e}))),l=async e=>{const t=[];for(;;){const r=c.pop();if(!r)return e(t);const[n,s]=await u(o)(r.item);t.push({error:n,result:s,index:r.index})}},a=n(1,e).map((()=>new Promise(l))),p=await Promise.all(a),[f,x]=s(t(p.flat(),(e=>e.index)),(e=>!!e.error));if(f.length>0)throw new i(f.map((e=>e.error)));return x.map((e=>e.result))},exports.partial=(e,...t)=>(...r)=>e(...t,...r),exports.partob=(e,t)=>r=>e({...t,...r}),exports.pascal=e=>{const t=e?.split(/[\.\-\s_]/).map((e=>e.toLowerCase()))??[];return 0===t.length?"":t.map((e=>e.charAt(0).toUpperCase()+e.slice(1))).join("")},exports.pick=(e,t)=>e?t.reduce(((t,r)=>(e.hasOwnProperty(r)&&(t[r]=e[r]),t)),{}):{},exports.proxied=e=>new Proxy({},{get:(t,r)=>e(r)}),exports.random=g,exports.range=r,exports.reduce=async(e,t,r)=>{const n=void 0!==r;if(!n&&e?.length<1)throw new Error("Cannot reduce empty array with no init value");const s=n?e:e.slice(1);let o=n?r:e[0];for(const e of s)o=await t(o,e);return o},exports.replace=(e,t,r)=>{if(!e)return[];if(!t)return[...e];for(let n=0;n<e.length;n++){if(r(e[n],n))return[...e.slice(0,n),t,...e.slice(n+1,e.length)]}return[...e]},exports.replaceOrAppend=(e,t,r)=>{if(!e&&!t)return[];if(!t)return[...e];if(!e)return[t];for(let n=0;n<e.length;n++){if(r(e[n],n))return[...e.slice(0,n),t,...e.slice(n+1,e.length)]}return[...e,t]},exports.retry=async(e,t)=>{const n=e?.times??3,s=e?.delay,o=e?.backoff??null;for(const e of r(1,n)){const[r,i]=await u(t)((e=>{throw{_exited:e}}));if(!r)return i;if(r._exited)throw r._exited;if(e===n)throw r;s&&await c(s),o&&await c(o(e))}},exports.select=(e,t,r)=>e.reduce(((e,n)=>r(n)?[...e,t(n)]:e),[]),exports.series=(...e)=>{const{itemsByValue:t,itemsByIndex:r}=e.reduce(((e,t,r)=>({itemsByValue:{...e.itemsByValue,[t]:r},itemsByIndex:{...e.itemsByIndex,[r]:t}})),{itemsByValue:{},itemsByIndex:{}});return{min:(e,r)=>t[e]<t[r]?e:r,max:(e,r)=>t[e]>t[r]?e:r,first:()=>r[0],last:()=>r[e.length-1],next:(e,n)=>r[t[e]+1]??n,previous:(e,n)=>r[t[e]-1]??n}},exports.shake=(e,t=(e=>void 0===e))=>{if(!e)return{};return Object.keys(e).reduce(((r,n)=>t(e[n])?r:{...r,[n]:e[n]}),{})},exports.shift=function(e,t){if(0===e.length)return e;const r=t%e.length;return 0===r?e:[...e.slice(-r,e.length),...e.slice(0,-r)]},exports.shuffle=e=>e.map((e=>({rand:Math.random(),value:e}))).sort(((e,t)=>e.rand-t.rand)).map((e=>e.value)),exports.sift=e=>e?.filter((e=>!!e))??[],exports.sleep=c,exports.snake=e=>{const t=e?.replace(/([A-Z])+/g,y).split(/(?=[A-Z])|[\.\-\s_]/).map((e=>e.toLowerCase()))??[];return 0===t.length?"":1===t.length?t[0]:t.reduce(((e,t)=>`${e}_${t.toLowerCase()}`))},exports.sort=t,exports.sum=(e,t)=>(e||[]).reduce(((e,r)=>e+(t?t(r):r)),0),exports.template=(e,t,r=/\{\{(.+?)\}\}/g)=>Array.from(e.matchAll(r)).reduce(((e,r)=>e.replace(r[0],t[r[1]])),e),exports.throttle=({interval:e},t)=>{let r=!0;return(...n)=>{r&&(t(...n),r=!1,setTimeout((()=>{r=!0}),e))}},exports.toFloat=(e,t)=>{const r=void 0===t?0:t;if(null==e)return r;const n=parseFloat(e);return isNaN(n)?r:n},exports.toInt=(e,t)=>{const r=void 0===t?0:t;if(null==e)return r;const n=parseInt(e);return isNaN(n)?r:n},exports.try=u,exports.tryit=u,exports.uid=(e,t="")=>{const r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"+t;return o(e,(e=>e+r.charAt(g(0,r.length-1))),"")},exports.unique=(e,t)=>{const r=e.reduce(((e,r)=>{const n=t?t(r):r;return e[n]?e:{...e,[n]:r}}),{});return Object.values(r)},exports.upperize=e=>d(e,(e=>e.toUpperCase())),exports.zip=m;
